<script type="text/javascript">

main(true) 

function main(isTesting = false) {
  // -----------------------------------------
  
  // Game Memory
  let gameState = {
    appIsActive: true,
    gameIsActive: true,
    name: 'Hero',
    hp: 20,
    attackBonus: 5,
    damage: 3,
    armorClass: 12,
    backpack: ['sword', 'cheese', 'cheese'],//since the other items dont matter we should only count cheese?
    monsterList: []
  }

  
  // -----------------------------------------
  // Game Details
  const monsters = [
    { 
      id: 0,
      minCount: 1,
      maxCount: 3,
      name: 'skeleton',
      hp: 10,
      attackBonus: 5,
      damage: 2,
      armorClass: 10,
      backpack: ['cheese']
    },
    { 
      id: 1,
      minCount: 1,
      maxCount: 3,
      name: 'zombie',
      hp: 13,
      attackBonus: 3,
      damage: 4,
      armorClass: 12,
      backpack: ['cheese']
    },
    { 
      id: 2,
      minCount: 0,
      maxCount: 1,
      name: 'dragon',
      hp: 20,
      attackBonus: 10,
      damage: 10,
      armorClass: 18,
      backpack: ['gold']
    }
  ]
  
  const optionsText = " Fight | Explore | Exit"
  
  const optionsExplore = {
    1: 'Explore filler text 1',
    2: 'Explore filler text 2',
    3: 'Explore filler text 3',
    4: 'Explore filler text 4',
    5: 'Explore filler text 5',
  }
  
  
  // -----------------------------------------
  // Begin Execution
  // Start Application Loop
  startApp()
  
  // -----------------------------------------
  // Game Functions
  
  function startApp() {

    // Menu screen (top-level loop)
    while(gameState.appIsActive) {
      let option = prompt('Welcome to The Elder Scripts III!  Play | Quit');
      
      
      if(option === null) {
        gameState = exitApp(gameState)
      } else {
        
        option = option.toLowerCase()
        
        switch (option) {
          case 'play':
            startGame()
            break;

          case 'quit':
            gameState = exitApp(gameState)
            break;
        }
      
      }
    }
    
  }

  // --------------
  function startGame() {
    
    // TODO: Generate a list of monsters (update gameState.monsterList)
    gameState.monsterList = []
    /*
      gameState.monsterList = monsters.reduce((list, element) => (
        list = [...list, ...Array(randomizer(3)).fill(element)]
      ), [])
    */
    
    // Initialize the initial state
    // Example: 
    //    default: gameState
    //    gameStates: [gameState1, gameState2, gameState3]

    while(gameState.gameIsActive === true) {
    
      
      // Current Stats Board - Appended to Prompt
      let bpItems = gameState.backpack.map( x => ' ' + x.charAt(0).toUpperCase() + x.slice(1) );
      let currStats = 'Current Stats\n--------------\nHealth: ' + gameState.hp + '\nAttack Bonus: ' + gameState.attackBonus + '\nArmor: ' + gameState.armorClass + 
          '\nDamage: ' + gameState.damage + '\nBackpack: ' + bpItems + '\n\n';
      
      // Phase 1
      let userSelection = input(currStats + 'What would you like to do?' + optionsText)//where is this?
      
      // Exits the game if the user selects "Cancel"
      // Prevents an infinite loop
      if(userSelection === null) {
        gameState = exitGame(gameState)
      }
      
      userSelection = userSelection.toLowerCase().trim()
      
      // Phase 2
      // Run the selected action;
      //     Creates a new "game board" based
      //     on the end result of the action
      // Returns an object
      gameState = executeAction(gameState, userSelection)
    }
  }
  
  // --------------
  function executeAction(state, action) {
    
    // Fight | Look | Status | Undo | Exit
    switch (action) {
      case 'fight':
        return fightAction(state)
      case 'look':  // describe chamber and opponent
        return exploreAction(state);
      case 'exit':
        return exitGame(state)
        
      default: 
        return state
    }
  }
  
  // --------------
  function fightAction(state) {
   //hufe!!! we need rl already know what the opponent is....
    let opponent = opponentSelector(state);//creates a duplicate obj for the new monster

    output('Fighting a ' + oppenent.name + '!');//remknder as we cue for action
    let action = input('Will you: attack? defend? or heal?');

    // Sword | Shield | Cheese
    switch (attack) {
      case 'attack':
        return calculateFight(state, opponent, randomizer(20), action),
        break;
      case 'defend':  // 
        return calculateFight(state, opponent, randomizer(20), action),
        break;
      case 'heal':
        return calculateFight(state, opponent, randomizer(20), action),
        break;
      default: 
        return state
    } 
    
    if(action === null) {
      state = exitGame(state)
    }
         
  }

  //fight sction is recursive because we have three distinct base cases...
  //one when NPC HP =0
  //two whwn PC HP =0
  //three of the player flees, and maybe we dont do this fpr simplicity
  //we ca'l the function each time AFTERrunning thrugh the logic of the calculare fight function
  //whenwe call it we willmpass it the updates obj values //until base case, rhen we pass the final all the way and that object
  //either pc or npd gets returned to the execute which will go back to main loop 
  //if the pc object has 0hp game over else we will peompt for the next action and intrpduce the next room
  
  
  function calculateFight(state, opponent, num, action) {//dup monster obj gets passed here so we can track hp?
      //let cheese = 5; // how much hp gained when PC eats cheese
      //let cheeseCount = 0; //# of cheeses in backpack rn
      //let copyOfPC = state; //this creates a copy of the PC obj so we can modify data without touching the global obj until we return 
/*  if (action === attack) {

        //if the PC attack hits
        if (copyOfPC.attackBonus + num >= opponent.armorClass) { 
            opponent.hp: opponent.hp - copyOfPC.attackBonus;
            output('You attack the ' + opponent.name + ' for ' + copyOfPC.damage + ' damage!');
        }
        //if the PC attack misses
        else if (copyOfPC.attackBonus + num >= opponent.armorClass) {
            output('Your attack is blocked by the ' + opponent.name);
        }
        //if the NPC attack hits the PC
        if (oppenent.attackBonus + num >= copyOfPC.armorClass) {
            copyOfPC.hp= copyOfPC.hp - oppenent.damage;   
            output('The ' + oppenent.name + ' hit you for ' + oppenent.damage + ' damage!');
            output('Current HP: ' + copyOfPC.hp);
        }
        //if the NPC attack misses the PC
        else if (opponent.attack + num < copyOfPC.armorClass) {
            output('The ' + opponent.name ' attacks, but you dodge!')
            output(Current HP: copyOfPC.hp)
        }
    }
    else if (action === defend) {
        //defending bonus increases armor class by 5
        //if the NPC attack misses the PC
        if (opponent.attackBonus + num < (copyOfPC.armorClass + 5) {
            output('The ' + opponent.name + ' attacks, but you block the attack!')
        }
        //if the NPC attck hits the PC
        else if (opponent.attackBonus + num >= (copyOfPC.armorClass + 5)) {
            output('You try to block, but the ' + opponent.name + '\'s attack strikes you for ' + opponent.damage + '!')
            copyOfPC.hp: copyOfPC.hp - opponent.damage;
            output('Current HP: ' + copyOfPC.hp;
        }
    }
    else if (action === heal) {
    
        if (copyOfPC.backpack.indexOf('cheese') === -1) {
            output('You are out of cheese! Choose a different action!');
        }
        else {
            for (let i = 0; i < copyOfPC.backpack.length; i++) {
                if (copyOfPC.backpack[i] === cheese) {
                    cheeseCount++;
                }
            }
            copyOfPC.hp: copyOfPC.hp + cheese;
            output('You eat some cheese and gain ' + cheese + ' HP! Current HP: ' + copyOfPC.hp + '. You have ' + cheeseCount ' left!');
        }
    }

    */
    
    // create algorithm to generate results 
    // update state results
    // print results 
    // return to menu
    return copyOfPC //(...state,); 
  }

  
  // --------------
  function opponentSelector(state){//create a duplicate object which can track hp w/o modding original obj
    const [monster, ...allOfTheOtherMonsters] = state.monsterList
    state.monsterList = [...allOfTheOtherMonsters]
    
    return monster
  }
  
  // --------------
  function exitGame(state) {
    output('You left the game.')
    return {...state, gameIsActive: false}
  }
  
  // --------------
  function exitApp(state) {
    output('Goodbye. Hasta Luego.')
    exit();
  }
  
  // --------------
  function viewStatus(state) {
    output('Your Status: <br>');
    output(JSON.stringify(state.player, null, 2));
    return state
  }
  
  function exploreAction(state) {
    output(exploreGenerator(state));
    console.log('explore action:' + state)
    return state
  } 
  
  function undoAction(states) {
    states = removeLastElement(states)
    return states[states.length - 1]
  }

  // --------------
  function output(str) {
    document.write(JSON.stringify(str, null, 2) + '<br>')
  }
  
//   // --------------
//   function outputMulti(str) {
//     document.write(JSON.stringify(str, null, 2) + '<br>')
//   }

  // --------------
  function input(str) {
    return prompt(str)
  }
  
  // --------------
  function devLog(...rest) {
    if(isTesting) {
      console.log(...rest)
      document.write(JSON.stringify(rest, null, 2) + '<br>')
    }
    // else, show nothing if app is live
  }
  
  // --------------
  // Option for randomizing rooms and opponents
  function randomizer(max, min = 1){
    return Math.floor((Math.random() * max) + min);
  }
  
  // --------------
  function exploreGenerator(state){
    let story = randomizer(5);
    return confirm(optionsExplore[story.toString()])
  }
  
  // --------------
  
  
  function shuffle(array) {
    let newArray = [...array]
    for (let index = array.length - 1; i > 0; i--) {
      
        const randomNumber = Math.floor(Math.random() * (i + 1));
      
        [newArray[index], newArray[randomNumber]] = [newArray[randomNumber], newArray[index]];
    }
    return a;
  }  
 
}
  

  
  


/* Game Notes

Game Flow:

1. User runs game. Press green 'Run' button at the bottom.
2. Prompt "Welcome to The Elder Scripts III!  Play | Load Last Save // Denny | Quit"
3. Play:  Output -> Initial story text, sets the scene.
4. Prompt Action Loop: Fight | Explore | Status | Exit | Undo

  a. Fight
      -> Prompt: Story Text with Monster. Attack | Defend | Item | Run
            a. Attack
            b. Defend
            c. Item
            d. Run
      -> Creates new state based on current state value *MOST COMPLICATED 
      -> Print end result, goes back to Action Loop
      
  b. Explore
      -> Output - Filler Text, randomizer 
      
  c. Status
      -> Output - current player's state: health, attack rating
      
  d. Exit
      -> exitGame function, ends current loop, goes back to StartGame loop
      
  e. Undo
      -> DENNY
      
5. Returns to startGame options, Returns to number 2.





> The Elder Scripts III

> One class - fighter
  >> attack
  >> block
  >> run
  >> use item
  backpack: [cheese, sword, shield, cheese]

const fighter = {
  attack: 5, 
  defense: 12,
  speed: 30,
  backpack: [
    cheese,
    sword,
    shield
  ]
  
}

>random array of opponents (3)
>> (0) skeleton, (1) zombie, (2) dragon

>>>skeleton
  >hp
  >armor class
  >attack

>>>zombie
  >hp
  >armor class
  >bite 
  >attack

>>>dragon
  >hp
  >armor class
  >fire attack

>> certain # of chambers 
>>>

>>Features

1) game loop start to finish (do while PC hp > 0??) 
2) get PC
3) random chambers --> encounters
4) NPC
5) control flow(while NPC hp > 0) for attacking and defending 
  > if PC hp = 0 end
6) PC goes to new loop in #3
7) health points tracking
8) flavor text (narative)
*/
// --------------
</script>
